<?php
/**
 * Implements hook_permission().
 */
function gvop_permission() {
  return array(
    'administer gvop settings' => array(
      'title' => t('Administer gvop settings'),
      'description' => t('Allows users to configure GVOP settings.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function gvop_menu() {
  $items = array();

  $items['admin/config/content/gvop'] = array(
    'access arguments' => array('administer gvop settings'),
    'page arguments' => array('gvop_admin_settings_form'),
    'page callback' => 'drupal_get_form',
    'file' => 'gvop.admin.inc',
    'title' => 'GVOP',
    'description' => 'Configure GVOP settings.',
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Implements hook_node_delete().
 */
function gvop_node_delete($node) {
  if ($node->type == 'announcement') {
    db_delete('gvop')->condition('nid', $node->nid)->execute();
  }
}

/**
 * Implements hook_cron().
 */
function gvop_cron() {
  $last_run = variable_get('gvop_cron_last_run', 0);
  $modified_str = 'modified>' . date('Y-m-d', $last_run);

  $gvop_info = module_invoke_all('gvop_info');
  foreach ($gvop_info as $type_info) {
    // Get count
    $dom = _gvop_retrieve_dom($type_info, 0, 1, array($modified_str));
    $num_results = (int)$dom->getElementsByTagName('numberOfRecords')->item(0)->nodeValue;
    $i = 0;

    while ($i < $num_results) {
      $dom = _gvop_retrieve_dom($type_info, $i, variable_get('gvop_limit', 100), array($modified_str));
      $xpath = new DOMXPath($dom);
      $records = $dom->getElementsByTagName("gzd");

      foreach ($records as $record) {
        $node = _gvop_map_node($type_info, $record, $xpath, TRUE);
        $i++;
      }
    }
  }

  variable_set('gvop_cron_last_run', time());
}

/**
 * Helper function to retrieve the uri for requesting.
 *
 * @param $start
 * @param $limit
 * @return string
 */
function _gvop_build_uri($type_info, $start, $limit, $params = array()) {
  $uri = variable_get('gvop_uri', 'https://zoek.officielebekendmakingen.nl/sru/Search');
  $query = array(
    'version' => '1.2',
    'operation' => 'searchRetrieve',
    'x-connection' => $type_info['type'],
    'startRecord' => $start,
    'maximumRecords' => $limit,
    'query' =>
    'creator==' . variable_get('gvop_creator', 'amsterdam')
  );
  foreach ($type_info['query'] as $key => $value) {
    $query['query'] .= ' and ' . $key . '==' . $value;
  }
  foreach ($params as $param) {
    $query['query'] .= ' and ' . $param;
  }
  return $uri . '?' . drupal_http_build_query($query);
}

/**
 * Helper function to retrieve the DOMDocument.
 *
 * @param $start
 * @param $limit
 * @return DOMDocument
 */
function _gvop_retrieve_dom($type_info, $start, $limit, $params = array()) {
  $uri = _gvop_build_uri($type_info, $start, $limit, $params);
  drupal_set_message($uri);
  $content = drupal_http_request($uri);

  // @todo, add error reporting for HTTP request and Diagnose response

  $dom = new DOMDocument();
  $dom->loadXML($content->data);

  return $dom;
}

/**
 * Function to map a gvop node.
 *
 * @param $type_info
 * @param DOMElement $record
 * @param DOMXPath $xpath
 * @param bool $force
 * @return bool|mixed|stdClass
 */
function _gvop_map_node($type_info, DOMElement $record, DOMXPath $xpath, $force = FALSE) {
  $identifier = $xpath->query('.//dcterms:identifier', $record)->item(0)->nodeValue;

  // Get the current version from the database.
  $current = db_select('gvop', 'g')
    ->fields('g', array('identifier', 'hash', 'nid'))
    ->condition('identifier', $identifier)
    ->execute()
    ->fetchAssoc();

  // Generate an hash for checking the update.
  $xml = $record->ownerDocument->saveXML($record);
  $xml_hash = md5($xml);

  // Is this an actual update.
  if (!$force && $current && $xml_hash == $current['hash']) {
    return FALSE;
  }

  // Are we updating or inserting.
  $modified = strtotime($xpath->query('.//dcterms:modified', $record)->item(0)->nodeValue);
  if ($current && !empty($current['nid'])) {
    $node = node_load($current['nid']);
  }
  else {
    $node = new stdClass();
    $node->uid = 1;
    $node->created = $modified;
    $node->type = 'announcement';
  }

  // Set common info.
  $node->gvop_identifier = $identifier;
  $node->title = substr($xpath->query('.//dcterms:title', $record)->item(0)->nodeValue, 0, 255);
  $node->changed = $modified;

  // Run the callback for mapping this type.
  $type_info['callback']($record, $node, $xpath);

  node_save($node);

  // Add to the GVOP table for hash checking and identifying.
  db_delete('gvop')
    ->condition('identifier', $identifier)
    ->execute();
  db_insert('gvop')
    ->fields(array('identifier' => $identifier, 'hash' => $xml_hash, 'nid' => $node->nid))
    ->execute();

  return $node;
}

/**
 * Function for retrieving terms. If a term does not exist adds it.
 *
 * @param $name Name of the term.
 * @param $voc_name Machine name of the vocabulary
 */
function gvop_get_term_id($name, $voc_name) {
  $term_match = taxonomy_get_term_by_name($name, $voc_name);
  if (!empty($term_match)) {
    $term = reset($term_match);
  }
  else {
    $voc = taxonomy_vocabulary_machine_name_load($voc_name);

    $term = new stdClass();
    $term->name = $name;
    $term->vid = $voc->vid;
    taxonomy_term_save($term);

    if (module_exists('domain_taxonomy')) {
      // domain_taxonomy always expects the terms source domain.
      $default_domain = domain_default();
      $term->domain_source = $default_domain['domain_id'];

      // allow access to all affiliates.
      $term->domain_site = TRUE;

      // Domain Taxonomy doesnt use hooks for loading / adding additional
      // data. Instead it alters the form and adds some custom fucntionality.
      // We have to do this ourselfs or else the terms willl not show.
      domain_taxonomy_save_term($term);
    }
  }

  return $term;
}